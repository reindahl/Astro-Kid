\section{General planning}
	The idea of using a general planner is that its possible to solve the problem efficiently, without building a planner from scratch for each problem. The general planer will however nearly always be less efficient than an planner for the specific problem. %This is due to...
	The main question is therefore if the general planner can solve the problem efficiently enough to be useful.

	To begin solving the problem with a general planner, the domain needs to be described in a Planning languages. In this case PDDL is suitable choice since it is a expressive language and used for the IPC, and there therefore exists a series of planners that support the language.
 

%	single agent planing
	  
%	complete PDDL not fully supported by most planners
	
	The general planner there will be used is Fast Downward, Fast Downward was chosen due to it being open source and it has done well in several IPC, and must therefore be considered one of the better planer out there, even though it only support a subset (PDDL 2.2 level 1 + action cost) of the complete PDDL.
	One of the things that differentiate Fast Downward from other planners is that it dosnt directly use PDDL for the planning but instead translates it first. 
 
 \subsection{PDDL}
	%TODO: Describe pddl
	The chosen planer is Fast Downward, which is limited to PDDL 2.2 level 1 + action cost, therefore this subset of PDDL will be used.

	\subsubsection{The Astro kid world}
	%TODO: general describtion of the world
	The Astro Kid game is a discrete world where everything moves in a 2d grid.
	Fully observable domain.
	the player is the only one who can start a new action (single agent). These new actions are...
			main actions
				move
					up, down, horizontally 
				push
				activate
	everything else is effects/consequences of these actions
	
	continuous actions
	concurrent actions
	

	
		
	When looking at the Astro Kid domain, its worth noting the main areas where it differentiates from classical planner domains like the gripper. These areas is concurrent actions and continuous effects. 
	
	
	%two approaches
	there are used two main approaches to describing the domain in PDDL
		
	due to how the domain differentiate from the classic type of problems.....
	
	the domain can either be transform into a more classic planning domain or use the structure as is.
	
		% basic structure grid predicates and so on...
		even though there are several approach to the problem the main structure remains the same. The differences between the approaches lies in the action available and the ordering in the domain. 
		
		uses the same basic structure
		
		each point in the world is represented in PDDL as an object and its location is defined relative to its neighbours. Everything else's locations in the domain is defined relative to these locations.
		
		item representation. object or predicate
		
		
		action cost is used to ensure that its only player actions which counts toward the plan cost.
		
		
		%problem describtion
			% is this worth writing abour?
		
	
		% Classic approach
		The main problem area with the classical approach is that PDDL doesn't directly allow concurrent actions, unless they are changed into a single action. This could be done by having a action for each possible combination of objects moving, This approach would however leads to an explosion of possible actions since the number of actions would then be depend on the number of objects that can have a continuous effect. The scaling would therefore be terrible (insert number). To avoid this problem some assumptions could be made about the domain so it would fit better into a classic planning paradigm. 
		
		the assumption is that moving objects dont interact with each other. this means that concurrency can be avoid in the pddl, by letting one of the concurrent actions completely terminate, before the next is considered. if this assumption holds, it would be possible to find the optimal solution.
		
		player stands still and wait for the other objects to stop moving. this is due to that the effect of the other moving object... effects the player...thing needs to get out of the way... press button and so on.... 
		
		
		if problems occurs between multiple moving objects 
		this assumption can in most cases (slide + robot activate, fx. level 31) be ensured by inserting noOps into the plan after a solution is found.... ensuring only one thing moves at the time... this however results in a not necessarily the optimal solution.... there might be few instances where two moving objects needs to interact to solve the problem. 
		
		
		
		the main advantage of doing this, is that the general planners are optimized for this kind of problems, since that is usually what they handle.
		
		
		
		This means that each action needs a rather large set of precondition, this to ensure that not only is the precondition for the given action fulfilled but also that no other action is locked from running/executing. the main precondition for most of the action are therefore a condition that ensures that nothing else is moving.
		
		there is a few exceptions to this approach
			pick up
			teleport
			activate
				can be applied while the player moves
		
		
		% other approach
		the main idea of using the domain as it is, to avoid enforcing/making assumption of the domain, which can effect the quality of the found solutions.
		guaranties optimal and legal solution
		
		is to focus on that there basically are two types of actions in the domain, the ones where the planner has a choice (player action) and actions which are consequences/updates of earlier actions. The main idea is therefore to separate the domain into input/choice and update, and then enforcing a ordering of the actions so a input/choice is always followed by an update. The ordering of actions can be enforced by using flags.	
		
		The update step is itself split up into multiple parts with a strict ordering, to enforce that the concurrent actions interact correctly with each others. The update step is separated into, removing objects, changing direction of objects, moving objects, collecting items, opening/closing gates, teleportation. And universal quantifiers are used to ensure all the continuous effects are applied.
		
		a problem with this approach is that how the strict ordering of actions (update), differentiates from the usually approach used in general planning, this means....
	
			%try with the axiom gate

	
	
	
	% old stuff
%	Astro Kid is a discrete world where everything moves in a 2d grid, each point in the world is represented in PDDL as an object and its location is defined relative to its neighbours. Everything else's locations in the domain is defined relative to these locations.
	
	
%	When looking at the Astro Kid world, its worth noting the main areas where it differentiates from classical planner domains like the gripper. These areas is concurrent actions and continuous effects. 
%	The continuous actions are where the planner cant change what is happening to a object before the action has ended, these actions is things such as falling, sliding and robots walking. They are handled by locking an objects to a given course of actions by creating a predicate with it. The created predicate is used as a guard to ensure that other actions dosnt interact with the object and only the locked action can be performed on the object.
	
	
	%To allow the planner to more efficiently solve problems in the domain, it is not possible to allow a continuous action to completely stop before the next action starts.
	
	%	worth of note is that even though its a single agent world, multiple things can happen concurrent. this i mainly due to that some actions have continuous effects.
	
%	To allow the planner to more efficiently solve problems  in the domain, continuous action should not be allow to completely stop before the next action starts. This is to avoid the agent standing still will something moves somewhere else. Therefore some kind of parallelism is needs. PDDL doesn't directly allow concurrent actions, unless they are changed into a single action. This could be done by having a action for each possible combination of objects moving, This approach would however leads to an explosion of possible actions since the number of actions would then be depend on the number of objects that can have a continuous effect. The scaling would therefore be terrible. The approach might however still work, if working under the assumption that the number of objects in the problem is fairly limited. Another approach and the chosen one, is to focus on that there basically are two types of actions in the domain, the ones where the planner has a choice (player action) and actions which are consequences/updates of earlier actions. The main idea is therefore to separate the domain into input/choice and update, and then enforcing a ordering of the actions so a input/choice is always followed by an update. The ordering of actions can be enforced by using flags.	
		
%	The update step is itself split up into multiple parts with a strict ordering, to enforce that the concurrent actions interact correctly with each others. The update step is separated into, removing objects, changing direction of objects, moving objects, collecting items, opening/closing gates, teleportation. And universal quantifiers are used to ensure all the continuous effects are applied.

	 
